"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMasonlyData = void 0;
const react_1 = require("react");
const useRectWidthHeight_1 = require("./useRectWidthHeight");
const useThrottle_1 = require("./useThrottle");
exports.useMasonlyData = ({ ref, minColumnWidth, gap, itemCount, }) => {
    const { width: rowWidth } = useRectWidthHeight_1.useRectWidthHeight(ref);
    const columnCount = Math.max(Math.floor(rowWidth / minColumnWidth), 1);
    const columnWidth = (rowWidth - gap * (columnCount - 1)) / columnCount;
    // Use ref to avoid recreating setSizeRatio func
    const sizeRetioMapRef = react_1.useRef(new Map());
    // To detect sizeRetioMapRef change
    const [lastChangedIndex, setLastChangedIndex] = react_1.useState();
    const setSizeRatio = react_1.useCallback((index, ratio) => {
        sizeRetioMapRef.current.set(index, ratio);
        setLastChangedIndex(index);
    }, [sizeRetioMapRef, setLastChangedIndex]);
    const [throttledItemPositionMap, maxHeight] = useThrottle_1.useThrottle((itemCount, _, columnCount, columnWidth, margin) => {
        const itemPositionMap = new Map();
        const columns = Array.from({
            length: columnCount,
        }).map((_, index) => ({
            height: 0,
            index,
        }));
        Array.from({ length: itemCount }).forEach((_, index) => {
            const column = [...columns].sort((c1, c2) => c1.height - c2.height)[0];
            const top = column.height;
            const left = (columnWidth + margin) * column.index;
            itemPositionMap.set(index, { top, left, width: columnWidth });
            column.height +=
                (sizeRetioMapRef.current.get(index) || 1) * columnWidth + margin;
        });
        return [
            itemPositionMap,
            columns.sort((c1, c2) => c2.height - c1.height)[0].height,
        ];
    }, [itemCount, lastChangedIndex, columnCount, columnWidth, gap], 20);
    const itemPositionMap = new Map(throttledItemPositionMap);
    // throttledItemPositionMap may not have position data for item because it's throttled
    Array.from({ length: itemCount }).forEach((_, index) => {
        if (!itemPositionMap.has(index)) {
            const assumedHeight = columnWidth;
            itemPositionMap.set(index, {
                top: (assumedHeight + gap) * Math.floor(index / columnCount),
                left: (columnWidth + gap) * (index % columnCount),
                width: columnWidth,
            });
        }
    });
    return {
        setSizeRatio,
        itemPositionMap,
        maxHeight,
    };
};
